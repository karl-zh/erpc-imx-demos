/*
 * Generated by erpcgen 1.7.1 on Fri Mar 22 16:36:06 2019.
 *
 * AUTOGENERATED - DO NOT EDIT
 */


#include "erpc_client_manager.h"
#include "erpc_port.h"
#include "erpc_codec.h"
extern "C"
{
#include "erpc_psa_api.h"
}

#if 10701 != ERPC_VERSION_NUMBER
#error "The generated shim code version is different to the rest of eRPC code."
#endif

using namespace erpc;
using namespace std;

extern ClientManager *g_client;


// Constant variable definitions
#pragma weak matrix_size
extern const int32_t matrix_size = 5;

//! @brief Function to write struct psa_invec
static void write_psa_invec_struct(erpc::Codec * codec, const psa_invec * data);

//! @brief Function to write struct psa_outvec
static void write_psa_outvec_struct(erpc::Codec * codec, const psa_outvec * data);


// Write struct psa_invec function implementation
static void write_psa_invec_struct(erpc::Codec * codec, const psa_invec * data)
{
    codec->write(data->base);

    codec->write(data->len);
}

// Write struct psa_outvec function implementation
static void write_psa_outvec_struct(erpc::Codec * codec, const psa_outvec * data)
{
    codec->write(data->base);

    codec->write(data->len);
}



// MatrixMultiplyService interface erpcMatrixMultiply function client shim.
void erpcMatrixMultiply(Matrix matrix1, Matrix matrix2, Matrix result_matrix)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kMatrixMultiplyService_service_id, kMatrixMultiplyService_erpcMatrixMultiply_id, request.getSequence());

        for (uint32_t arrayCount0 = 0; arrayCount0 < 5; ++arrayCount0)
        {
            for (uint32_t arrayCount1 = 0; arrayCount1 < 5; ++arrayCount1)
            {
                codec->write(matrix1[arrayCount0][arrayCount1]);
            }
        }

        for (uint32_t arrayCount0 = 0; arrayCount0 < 5; ++arrayCount0)
        {
            for (uint32_t arrayCount1 = 0; arrayCount1 < 5; ++arrayCount1)
            {
                codec->write(matrix2[arrayCount0][arrayCount1]);
            }
        }

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        for (uint32_t arrayCount0 = 0; arrayCount0 < 5; ++arrayCount0)
        {
            for (uint32_t arrayCount1 = 0; arrayCount1 < 5; ++arrayCount1)
            {
                codec->read(&result_matrix[arrayCount0][arrayCount1]);
            }
        }

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, kMatrixMultiplyService_erpcMatrixMultiply_id);

    return;
}

// PsaFrameworkVersionService interface psa_framework_version function client shim.
uint32_t psa_framework_version(void)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kPsaFrameworkVersionService_service_id, kPsaFrameworkVersionService_psa_framework_version_id, request.getSequence());

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, kPsaFrameworkVersionService_psa_framework_version_id);

    if (err)
    {
        return 0xFFFFFFFFU;
    }

    return result;
}

// PsaVersionService interface psa_version function client shim.
uint32_t psa_version(uint32_t sid)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kPsaVersionService_service_id, kPsaVersionService_psa_version_id, request.getSequence());

        codec->write(sid);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, kPsaVersionService_psa_version_id);

    if (err)
    {
        return 0xFFFFFFFFU;
    }

    return result;
}

// PsaConnectService interface psa_connect function client shim.
psa_handle_t psa_connect(uint32_t sid, uint32_t minor_version)
{
    erpc_status_t err = kErpcStatus_Success;

    psa_handle_t result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kPsaConnectService_service_id, kPsaConnectService_psa_connect_id, request.getSequence());

        codec->write(sid);

        codec->write(minor_version);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, kPsaConnectService_psa_connect_id);

    if (err)
    {
        return -1;
    }

    return result;
}

// PsaCallService interface psa_call function client shim.
psa_status_t psa_call(psa_handle_t handle, const psa_invec * in_vec, uint32_t in_len, const psa_outvec * out_vec, uint32_t out_len)
{
    erpc_status_t err = kErpcStatus_Success;

    psa_status_t result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kPsaCallService_service_id, kPsaCallService_psa_call_id, request.getSequence());

        codec->write(handle);

        write_psa_invec_struct(codec, in_vec);

        codec->write(in_len);

        write_psa_outvec_struct(codec, out_vec);

        codec->write(out_len);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, kPsaCallService_psa_call_id);

    if (err)
    {
        return -1;
    }

    return result;
}

// PsaCloseService interface psa_close function client shim.
void psa_close(psa_handle_t handle)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kPsaCloseService_service_id, kPsaCloseService_psa_close_id, request.getSequence());

        codec->write(handle);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, kPsaCloseService_psa_close_id);

    return;
}
